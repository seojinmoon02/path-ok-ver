<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>Code Path â€“ Game (Shape Match)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <script src="https://cdn.jsdelivr.net/npm/p5@1.7.0/lib/p5.min.js"></script>

  <style>
    :root {
      --accent: #ef4136;
      --accent-soft: #fef4f3;
      --text-main: #111827;
      --text-sub: #6b7280;
      --border-soft: #e5e7eb;
    }

    body {
      margin: 0;
      padding: 0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #ffffff;
      color: var(--text-main);
    }

    /* --- Make canvas visually match UI width --- */
    main {
      margin-top: 18px;
      width: min(700px, 95vw);
      display: flex;
      justify-content: center;
    }

    main canvas {
      width: 100%;
      height: auto;
      background: #ffffff;
      box-shadow: 0 0 0 1px #ffffff, 0 2px 8px rgba(0,0,0,0.08);
      border-radius: 4px;
      display: block;
    }

    #ui {
      width: 700px;
      max-width: 95vw;
      margin-top: 10px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      font-size: 14px;
    }

    #topRow {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 6px;
    }

    #tripNav {
      display: flex;
      align-items: baseline;
      gap: 10px;
    }

    #levelTitle {
      font-weight: 700;
      font-size: 18px;
      letter-spacing: 0.02em;
      color: var(--accent);
    }

    .navArrow {
      width: 34px;
      height: 34px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border-radius: 999px;
      border: 1px solid var(--border-soft);
      background: #fff;
      color: var(--accent);
      cursor: pointer;
      box-shadow: none;
      font-size: 18px;
      line-height: 1;
      padding: 0;
      transition: background 0.15s ease, transform 0.08s ease, box-shadow 0.15s ease;
    }
    .navArrow:hover {
      background: var(--accent-soft);
      transform: translateY(-1px);
      box-shadow: 0 2px 6px rgba(0,0,0,0.06);
    }
    .navArrow:active {
      transform: translateY(0);
      box-shadow: none;
    }

    #buttons {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    button {
      padding: 6px 12px;
      border-radius: 999px;
      border: 1px solid var(--accent);
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      background: var(--accent);
      color: #ffffff;
      box-shadow: 0 1px 3px rgba(0,0,0,0.15);
      white-space: nowrap;
      transition: background 0.15s ease, color 0.15s ease, box-shadow 0.15s ease, transform 0.08s ease;
    }

    button.secondary {
      background: #ffffff;
      color: var(--accent);
      box-shadow: none;
    }

    button:hover {
      background: #ff5c4e;
      box-shadow: 0 2px 6px rgba(0,0,0,0.18);
      transform: translateY(-1px);
    }
    button.secondary:hover {
      background: var(--accent-soft);
      color: var(--accent);
      box-shadow: 0 2px 6px rgba(0,0,0,0.06);
    }
    button:active {
      transform: translateY(0);
      box-shadow: 0 1px 3px rgba(0,0,0,0.12);
    }

    #status {
      padding: 6px 10px;
      background: #ffffff;
      border-radius: 6px;
      border: 1px solid var(--border-soft);
      box-shadow: 0 1px 2px rgba(0,0,0,0.03);
      color: var(--text-sub);
    }

    #instructions {
      padding: 8px 10px;
      background: var(--accent-soft);
      border-radius: 6px;
      border: 1px solid var(--accent);
      box-shadow: 0 1px 3px rgba(0,0,0,0.04);
      line-height: 1.5;
      color: var(--text-main);
    }
    #instructions b {
      font-weight: 600;
      color: var(--accent);
    }

    /* --- Mobile: prevent scrolling (only on small screens) --- */
    @media (max-width: 600px){
      html, body { height: 100%; overflow: hidden; }
      main { margin-top: 10px; }
    }

    /* --- Custom cursor --- */
    body, button, select, canvas {
      cursor: url("./assets/cursor-marker.svg") 8 20, auto;
    }

    /* --- Ink click effect --- */
    .ink {
      position: fixed;
      left: 0;
      top: 0;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: rgba(239,65,54,0.75);
      transform: translate(-50%, -50%);
      pointer-events: none;
      animation: inkSpread 0.45s ease-out forwards;
      z-index: 9998;
    }
    @keyframes inkSpread {
      from { transform: translate(-50%, -50%) scale(0.5); opacity: 0.6; }
      to   { transform: translate(-50%, -50%) scale(2.6); opacity: 0; }
    }

    /* --- Result card overlay (USED) --- */
    #resultOverlay {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.45);
      z-index: 9999;
    }
    #resultOverlay.show { display: flex; }
    #resultOverlay img {
      width: min(420px, 80vw);
      height: auto;
      border-radius: 12px;
      display: block;
    }

    /* --- Large desktop (iMac-class) scaling only --- */
@media (min-width: 2400px) and (min-height: 1200px){
  #ui{
    width: 1040px;        /* 700 -> 880 */
    font-size: 16px;     /* ê¸°ë³¸ ê¸€ì ì•½ê°„ í™•ëŒ€ */
  }

  #levelTitle{
    font-size: 22px;     /* 18 -> 22 */
  }

  button{
    font-size: 16px;     /* 14 -> 16 */
    padding: 8px 14px;   /* ì‚´ì§ í™•ëŒ€ */
  }

  #status{
    font-size: 16px;
    padding: 10px 12px;
  }

  #instructions{
    font-size: 16px;
    padding: 12px 12px;
    line-height: 1.6;
  }

  main{
    width: min(1040px, 95vw); /* ìº”ë²„ìŠ¤ë„ ê°™ì´ ì»¤ì§(í­ ê¸°ì¤€) */
  }
}

  </style>
</head>

<body>
  <main></main>

  <div id="ui">
    <div id="topRow">
      <div id="tripNav">
        <button id="prevTrip" class="navArrow" aria-label="Previous trip">â€¹</button>
        <div id="levelTitle">TRIP 01</div>
        <button id="nextTrip" class="navArrow" aria-label="Next trip">â€º</button>
      </div>

      <div id="buttons">
        <button id="resetBtn" class="secondary">Reset</button>
        <button id="undoBtn" class="secondary">Undo</button>
        <button id="langBtn" class="secondary">EN</button>
        <button id="checkBtn">Check Answer</button>
      </div>
    </div>

    <div id="status">Start from the START point and draw your path.</div>

    <div id="instructions">
      <b>Mouse Controls</b><br>
      - Click an adjacent point to extend your path from START.<br>
      - You can only move up, down, left, right, or diagonally.<br>
      - Double-click to break the line; the next point becomes a jump (J).<br>
      - After finishing your route, press <b>Check Answer</b>.
    </div>
  </div>

  <!-- ì •ë‹µ ì¹´ë“œ ì˜¤ë²„ë ˆì´ (í˜„ì¬ ë¡œì§ì—ì„œ ì‚¬ìš© ì¤‘) -->
  <div id="resultOverlay">
    <img alt="result card">
  </div>

  <script>
    "use strict";

    // ====== I18N ======
    const LANG = {
      en: {
        status: {
          start: "Begin your journey from the START marker. Chart your path across the grid.",
          reset: "Your route has been cleared. Youâ€™re ready to set off again.",
          split: "Path split â€” your next move will become a leap (J).",
          nearOnly: "You can only travel to nearby points. Try a step within reach.",
          noAnswer: "No official route is set for this TRIP yet.",
          correct: "Journey complete! ğŸ‰ Your path matches the official route (Shape Match).",
          wrong: "This route doesnâ€™t match the official path. Try exploring again.",
          undo: "Your last step has been undone."
        },
        instructions: `
          <b>Mouse Controls</b><br>
          â€¢ Click nearby points to draw your route across the grid.<br>
          â€¢ Move up, down, left, right, or diagonally.<br>
          â€¢ Double-click to break the route â€” the next move becomes a leap (J).<br>
          â€¢ Press <b>Check Answer</b> when you're done exploring.
        `,
        trip: n => `TRIP ${String(n).padStart(2, "0")}`
      },

      kr: {
        status: {
          start: "START ì§€ì ì—ì„œ ë‹¹ì‹ ì˜ ì—¬ì •ì„ ì‹œì‘í•˜ì„¸ìš”. ê·¸ë¦¬ë“œë¥¼ ë”°ë¼ ê¸¸ì„ ê°œì²™í•´ë³´ì„¸ìš”.",
          reset: "ê²½ë¡œê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì—¬ì •ì„ ì‹œì‘í•  ìˆ˜ ìˆì–´ìš”.",
          split: "ì„ ì´ ëŠê²¼ìŠµë‹ˆë‹¤. ë‹¤ìŒ ì ë¶€í„° ì í”„(J) êµ¬ê°„ìœ¼ë¡œ ì¸ì‹ë©ë‹ˆë‹¤.",
          nearOnly: "ì¸ì ‘í•œ ì (ìƒí•˜ì¢Œìš°/ëŒ€ê°ì„ )ìœ¼ë¡œë§Œ ì´ë™í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.",
          noAnswer: "ì´ TRIPì€ ì•„ì§ ì •ë‹µ ê²½ë¡œê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.",
          correct: "ì—¬ì • ì™„ë£Œ! ğŸ‰ ë‹¹ì‹ ì˜ ê²½ë¡œê°€ ì •ë‹µê³¼ ì¼ì¹˜í•©ë‹ˆë‹¤ (ëª¨ì–‘ ì¼ì¹˜).",
          wrong: "ì´ ê²½ë¡œëŠ” ì •ë‹µê³¼ ì¼ì¹˜í•˜ì§€ ì•Šì•„ìš”. ë‹¤ì‹œ íƒí—˜í•´ë³´ì„¸ìš”.",
          undo: "ë§ˆì§€ë§‰ ì›€ì§ì„ì„ ì·¨ì†Œí–ˆìŠµë‹ˆë‹¤."
        },
        instructions: `
          <b>ë§ˆìš°ìŠ¤ ì¡°ì‘</b><br>
          â€¢ ì¸ì ‘í•œ ì ë“¤ì„ í´ë¦­í•´ ê·¸ë¦¬ë“œ ìœ„ì— ì—¬ì •ì„ ê·¸ë¦½ë‹ˆë‹¤.<br>
          â€¢ ìƒí•˜ì¢Œìš° ë° ëŒ€ê°ì„ ìœ¼ë¡œ ì´ë™í•  ìˆ˜ ìˆì–´ìš”.<br>
          â€¢ ë”ë¸”í´ë¦­í•˜ë©´ ê¸¸ì´ ëŠì–´ì§€ë©°, ë‹¤ìŒ ì´ë™ì€ ì í”„(J)ê°€ ë©ë‹ˆë‹¤.<br>
          â€¢ íƒí—˜ì„ ë§ˆì¹˜ë©´ <b>ì •ë‹µ í™•ì¸</b> ë²„íŠ¼ì„ ëˆŒëŸ¬ë³´ì„¸ìš”.
        `,
        trip: n => `TRIP ${String(n).padStart(2, "0")}`
      }
    };

    let currentLang = "en";

    // ====== CONFIG ======
    const GRID_SIZE = 11;
    const BASE_MARGIN = 60;
    const CLICK_RADIUS = 16;

    let BASE_CANVAS_SIZE = 700;



    // ê° ë ˆë²¨ë³„ ì •ë‹µ ì½”ë“œ
    const ANSWER_CODES = {
      1: ["J","J","L","F","L","F","RBD","F","LBD","RBD","F","RFD","F","F","F","RFD","F","RBD","LBD","F","RBD","F","L","F","R","F","R","F","L","F","L","F","R","F","LT","LT","J","J"],
      2: ["J","J","F","RFD","F","LBD","F","LFD","RBD","RFD","LBD","LFD","RBD","LFD","F","R","R","R","F","LFD","RBD","LFD","LBD","RFD","RBD","LFD","F","LBD","F","RFD","L","F","F","LT","LT","J","LFD","R","R","R","LT","J","L","F","F","J","J"],
      3: ["F","L","F","L","RT","RT","J","R","F","R","F","L","L","F","R","RT","RT","J","F","F","L","F","L","F","L","F","RT","RT","J","R","F","F","R","F","L","L","F","R","F","RT","RT","J","R","L","F","L"],
      4: ["F","F","L","F","R","F","F","R","L","R","L","RFD","LFD","F","B","F","LFD","RFD","L","R","L","R","F","RT","RT","J","F","F","F","F","R","R","F","F","F","R","LT","LT","J","R","R","F","L","F"],
      5: ["J","J","R","L","F","F","F","F","F","L","F","F","F","F","F","L","F","F","F","F","F","L","F","F","F","F","LT","LT","J","F","F","F","F","L","F","F","F","L","F","F","F","L","F","F","F","J","J","J"],
      6: ["J","J","LFD","LFD","R","LFD","R","LFD","R","LFD","R","LFD","R","LFD","R","LFD","R","LFD","J","J"],
      7: ["J","F","F","L","F","F","R","R","F","F","L","L","F","F","R","R","F","F","L","L","F","F","R","R","F","F","L","L","F","F","F","F","L","F","F","F","F","F","F","F","L","F","F","F","F","J","J"],
      8: ["R","F","LFD","F","F","F","F","L","F","F","L","F","LFD","F","RFD","F","RFD","L","F","L","LT","LT","J","R","F","LFD","F","F","F","L","LBD","F","RT","RT","J","J","F","LFD","LBD","RT","RT","RT","J","J","J"],
      9: ["J","J","F","F","F","F","F","F","R","F","F","F","RFD","F","RFD","F","RFD","F","RFD","F","F","F","RT","RT","RT","J","J","LFD","F","R","F","R","F","R","F","LT","LT","J","J","J","J"],
      10:["J","J","J","F","F","R","F","RBD","F","R","F","RBD","F","F","F","F","F","F","LBD","F","F","LFD","F","F","F","LFD","F","F","LBD","F","F","RT","RT","RT","J","J","J"],
      11:["LFD","F","LFD","RFD","F","R","F","L","R","F","F","RFD","R","F","F","F","F","F","F","F","F","F"],
      12:["J","F","F","F","F","F","F","F","F","RBD","F","F","F","LFD","F","LFD","F","RBD","F","F","F","RBD","F","LFD","F","LFD","F","F","F","RT","J"]
    };

    // START points (grid index i,j)
    const START_POINTS = {
      1: { i: 8, j: 0 },
      2: { i: 10, j: 8 },
      3: { i: 6, j: 0 },
      4: { i: 10, j: 4 },
      5: { i: 0, j: 3 },
      6: { i: 0, j: 5 },
      7: { i: 8, j: 0 },
      8: { i: 10, j: 2 },
      9: { i: 6, j: 0 },
      10:{ i: 0, j: 5 },
      11:{ i: 7, j: 0 },
      12:{ i: 0, j: 1 }
    };

    // 0: N, 1: NE, 2: E, 3: SE, 4: S, 5: SW, 6: W, 7: NW
    const ORI_DIRS = [
      { di: -1, dj: 0 },
      { di: -1, dj: 1 },
      { di: 0,  dj: 1 },
      { di: 1,  dj: 1 },
      { di: 1,  dj: 0 },
      { di: 1,  dj: -1 },
      { di: 0,  dj: -1 },
      { di: -1, dj: -1 }
    ];

    const DRAW_CODES = ["F","L","R","B","LFD","RFD","LBD","RBD"];

    // ====== STATE ======
    let points = [];
    let segments = [];
    let activeSegment = null;
    let currentPointIndex = null;
    let startPoint = null;

    let level = 1;

    // UI
    let statusDiv, resetBtn, checkBtn, levelTitle, undoBtn, langBtn;

    // Canvas geometry
    let canvasSize = BASE_CANVAS_SIZE;
    let gridMargin = BASE_MARGIN;
    let spacing = 0;

    // Result overlay + confetti
    let resultMode = null; // "correct" | "wrong" | null
    let resultTimer = 0;
    let confettiParticles = [];
    let confettiBurstUntil = 0;

    // iMac-class large display only
if (window.screen.width >= 2400 && window.screen.height >= 1200) {
  BASE_CANVAS_SIZE = 1100;
}

    // ====== P5 ======
    function setup() {
      const canvas = createCanvas(BASE_CANVAS_SIZE, BASE_CANVAS_SIZE);
      canvas.parent(document.querySelector("main"));
      textFont("system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif");

      initLevelFromQuery();
      cacheDom();
      updateCanvasSize();   // sets spacing + initGrid()
      initGameState();
      applyLanguage();
      bindOverlayClose();
      bindInkEffect();
    }

    function draw() {
      background("#ef4136");
      drawGrid();
      drawBoardLabels();
      drawSegments();
      drawPoints();
      drawResultOverlay();
      updateAndDrawConfetti();
    }

    function windowResized() {
      updateCanvasSize();
    }

    // ====== INIT / DOM ======
    function initLevelFromQuery() {
      const q = new URLSearchParams(window.location.search);
      const lv = parseInt(q.get("level"), 10);
      level = (!isNaN(lv) && lv >= 1 && lv <= 12) ? lv : 1;
    }

    function cacheDom() {
      statusDiv = document.getElementById("status");
      resetBtn = document.getElementById("resetBtn");
      checkBtn = document.getElementById("checkBtn");
      levelTitle = document.getElementById("levelTitle");
      undoBtn = document.getElementById("undoBtn");
      langBtn = document.getElementById("langBtn");

      resetBtn.addEventListener("click", () => {
        initGameState();
        setStatus("reset");
      });

      checkBtn.addEventListener("click", onCheckAnswer);

      undoBtn.addEventListener("click", undoLastStep);

      window.addEventListener("keydown", (e) => {
        if ((e.key === "z" || e.key === "Z") && (e.metaKey || e.ctrlKey)) {
          e.preventDefault();
          undoLastStep();
        }
        if (e.key === "Escape") hideResultCard();
      });

      langBtn.addEventListener("click", () => {
        currentLang = currentLang === "en" ? "kr" : "en";
        langBtn.textContent = currentLang.toUpperCase();
        applyLanguage();
      });

      const prevTrip = document.getElementById("prevTrip");
      const nextTrip = document.getElementById("nextTrip");

      const goLevel = (newLv) => {
        newLv = Math.max(1, Math.min(12, newLv));
        if (newLv === level) return;

        level = newLv;
        const url = new URL(window.location);
        url.searchParams.set("level", level);
        window.history.pushState({}, "", url);

        initGameState();
        applyLanguage();
      };

      prevTrip.addEventListener("click", () => goLevel(level - 1));
      nextTrip.addEventListener("click", () => goLevel(level + 1));
    }

    function applyLanguage() {
      const L = LANG[currentLang];
      levelTitle.textContent = L.trip(level);
      document.getElementById("instructions").innerHTML = L.instructions;
      setStatus("start");
    }

    function initGameState() {
      segments = [];
      activeSegment = null;
      currentPointIndex = null;

      resultMode = null;
      resultTimer = 0;
      confettiParticles.length = 0;
      confettiBurstUntil = 0;

      // START (ì°¸ì¡°ìš©)
      const sp = START_POINTS[level] || { i: 0, j: Math.floor(GRID_SIZE / 2) };
      startPoint = points[ijToIndex(sp.i, sp.j)];
    }

    function setStatus(keyOrMsg) {
      if (!statusDiv) return;
      const L = LANG[currentLang];
      statusDiv.textContent = (L?.status?.[keyOrMsg]) ? L.status[keyOrMsg] : keyOrMsg;
    }

    // ====== CANVAS SIZE / GRID ======
    function updateCanvasSize() {
      const uiEl = document.getElementById("ui");
      const uiW = uiEl ? uiEl.getBoundingClientRect().width : windowWidth * 0.95;

      const isMobile = windowWidth <= 600;
      const sizeByWidth = uiW;
      const sizeByHeight = windowHeight * (isMobile ? 0.55 : 0.78);

      canvasSize = Math.min(BASE_CANVAS_SIZE, sizeByWidth, sizeByHeight);
      gridMargin = (BASE_MARGIN / BASE_CANVAS_SIZE) * canvasSize;

      resizeCanvas(canvasSize, canvasSize);

      spacing = (canvasSize - 2 * gridMargin) / (GRID_SIZE - 1);
      initGrid();
    }

    function initGrid() {
      points = [];
      let idx = 0;
      for (let i = 0; i < GRID_SIZE; i++) {
        for (let j = 0; j < GRID_SIZE; j++) {
          const x = gridMargin + j * spacing;
          const y = gridMargin + i * spacing;
          points.push({ x, y, i, j, index: idx++ });
        }
      }
    }

    // ====== INDEX HELPERS ======
    function indexToIJ(index) {
      const i = Math.floor(index / GRID_SIZE);
      const j = index % GRID_SIZE;
      return { i, j };
    }
    function ijToIndex(i, j) {
      return i * GRID_SIZE + j;
    }

    function isOnEdge(i, j) {
      return (i === 0 || j === 0 || i === GRID_SIZE - 1 || j === GRID_SIZE - 1);
    }

    function initialOrientationForStart(i, j) {
      if (i === 0) return 4;
      if (i === GRID_SIZE - 1) return 0;
      if (j === 0) return 2;
      if (j === GRID_SIZE - 1) return 6;
      return 4;
    }

    // ====== COMMANDS ======
    function applyCommand(ori, code) {
      let newOri = ori;
      let stepOri = ori;
      let type = "draw";

      switch (code) {
        case "F": stepOri = ori; break;
        case "B": newOri = (ori + 4) % 8; stepOri = newOri; break;
        case "L": newOri = (ori + 6) % 8; stepOri = newOri; break;
        case "R": newOri = (ori + 2) % 8; stepOri = newOri; break;
        case "J": stepOri = ori; type = "jump"; break;
        case "LFD": newOri = (ori + 7) % 8; stepOri = newOri; break;
        case "RFD": newOri = (ori + 1) % 8; stepOri = newOri; break;
        case "LBD": newOri = (ori + 5) % 8; stepOri = newOri; break;
        case "RBD": newOri = (ori + 3) % 8; stepOri = newOri; break;
        case "LT": return { newOri: (ori + 7) % 8, di: 0, dj: 0, type: "rotate" };
        case "RT": return { newOri: (ori + 1) % 8, di: 0, dj: 0, type: "rotate" };
        default:  return null;
      }

      const d = ORI_DIRS[stepOri];
      return { newOri, di: d.di, dj: d.dj, type };
    }

    function buildStepsFromSegments() {
      if (!segments || segments.length === 0) return [];
      const chronological = [];

      for (let s = 0; s < segments.length; s++) {
        const seg = segments[s];
        if (!seg.points || seg.points.length === 0) continue;

        for (let k = 0; k < seg.points.length - 1; k++) {
          chronological.push({ from: seg.points[k], to: seg.points[k + 1], type: "draw" });
        }

        if (s < segments.length - 1) {
          const nextSeg = segments[s + 1];
          if (seg.points.length > 0 && nextSeg.points.length > 0) {
            const from = seg.points[seg.points.length - 1];
            const to = nextSeg.points[0];
            if (from !== to) chronological.push({ from, to, type: "jump" });
          }
        }
      }

      return chronological;
    }

    function decodeCommandsToSteps(commands, startIndex, startOri) {
      let steps = [];
      let ori = startOri;
      let currentIndex = startIndex;

      for (let k = 0; k < commands.length; k++) {
        const res = applyCommand(ori, commands[k]);
        if (!res) {
          return { ok: false, error: `ì •ë‹µ ì½”ë“œì˜ ${k + 1}ë²ˆì§¸ ëª…ë ¹(${commands[k]})ë¥¼ í•´ì„í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`, steps: [] };
        }

        if (res.type === "rotate") {
          ori = res.newOri;
          continue;
        }

        const { i, j } = indexToIJ(currentIndex);
        const ni = i + res.di;
        const nj = j + res.dj;

        if (ni < 0 || ni >= GRID_SIZE || nj < 0 || nj >= GRID_SIZE) {
          return { ok: false, error: `ì •ë‹µ ì½”ë“œê°€ ê²©ì ë°–ìœ¼ë¡œ ë‚˜ê°‘ë‹ˆë‹¤. (step ${k + 1})`, steps: [] };
        }

        const nextIndex = ijToIndex(ni, nj);
        steps.push({ from: currentIndex, to: nextIndex, type: res.type });
        currentIndex = nextIndex;
        ori = res.newOri;
      }

      return { ok: true, error: "", steps };
    }

    // ====== SHAPE MATCH HELPERS ======
    function getEdgesFromSteps(steps) {
      const edges = new Set();
      for (const step of steps) {
        if (step.type !== "draw") continue;
        const a = Math.min(step.from, step.to);
        const b = Math.max(step.from, step.to);
        edges.add(`${a}-${b}`);
      }
      return edges;
    }

    function areEdgeSetsEqual(setA, setB) {
      if (setA.size !== setB.size) return false;
      for (const edge of setA) if (!setB.has(edge)) return false;
      return true;
    }

    // ====== ANSWER CHECK ======
    function onCheckAnswer() {
      const ans = ANSWER_CODES[level];
      if (!ans || !Array.isArray(ans) || ans.length === 0) {
        setStatus("noAnswer");
        return;
      }

      const playerSteps = buildStepsFromSegments();
      if (playerSteps.length === 0) {
        setStatus("ê²½ë¡œê°€ ì—†ìŠµë‹ˆë‹¤. ë¨¼ì € ê·¸ë¦¼ì„ ê·¸ë ¤ì£¼ì„¸ìš”.");
        resultMode = null;
        resultTimer = 0;
        confettiParticles.length = 0;
        return;
      }

      const sp = START_POINTS[level] || { i: 0, j: Math.floor(GRID_SIZE / 2) };
      const startIndex = ijToIndex(sp.i, sp.j);
      const startOri = initialOrientationForStart(sp.i, sp.j);

      const decoded = decodeCommandsToSteps(ans, startIndex, startOri);
      if (!decoded.ok) {
        setStatus(decoded.error);
        resultMode = null;
        resultTimer = 0;
        confettiParticles.length = 0;
        return;
      }

      const ok = areEdgeSetsEqual(getEdgesFromSteps(playerSteps), getEdgesFromSteps(decoded.steps));

      if (ok) {
        resultMode = "correct";
        resultTimer = 180;
        spawnFancyConfetti();
        showResultCard(`img/trip${String(level).padStart(2, "0")}.png`);
        setStatus("correct");
      } else {
        resultMode = "wrong";
        resultTimer = 180;
        confettiParticles.length = 0;
        setStatus("wrong");
      }
    }

    // ====== MOUSE INTERACTION ======
    function mousePressed() {
      if (mouseX < 0 || mouseX > width || mouseY < 0 || mouseY > height) return;
      const idx = findClickedPoint(mouseX, mouseY);
      if (idx === -1) return;
      handleClickOnPoint(idx);
    }

    function mouseDragged() {
      if (mouseX < 0 || mouseX > width || mouseY < 0 || mouseY > height) return;

      const idx = findClickedPoint(mouseX, mouseY);
      if (idx === -1) return;
      if (currentPointIndex === idx) return;

      // ë“œë˜ê·¸ë¡œ ì‹œì‘ ê°€ëŠ¥
      if (activeSegment == null) {
        activeSegment = { points: [idx] };
        segments.push(activeSegment);
        currentPointIndex = idx;
        return;
      }

      // ì¸ì ‘í•œ ê²½ìš°ë§Œ draw (ë“œë˜ê·¸ëŠ” ì í”„ ê¸ˆì§€)
      const p = points[idx];
      const lastP = points[currentPointIndex];
      const di = p.i - lastP.i;
      const dj = p.j - lastP.j;

      const isAdjacent = (Math.abs(di) <= 1 && Math.abs(dj) <= 1 && !(di === 0 && dj === 0));
      if (isAdjacent) {
        activeSegment.points.push(idx);
        currentPointIndex = idx;
      }
    }

    function doubleClicked() {
      if (currentPointIndex != null) {
        activeSegment = null;
        currentPointIndex = null;
        setStatus("split");
      }
      return false;
    }

    function findClickedPoint(mx, my) {
      let closestIndex = -1;
      let closestDistSq = CLICK_RADIUS * CLICK_RADIUS;

      for (let i = 0; i < points.length; i++) {
        const p = points[i];
        const dx = mx - p.x;
        const dy = my - p.y;
        const d2 = dx * dx + dy * dy;
        if (d2 <= closestDistSq) {
          closestIndex = i;
          closestDistSq = d2;
        }
      }
      return closestIndex;
    }

    function handleClickOnPoint(idx) {
      if (activeSegment == null) {
        activeSegment = { points: [idx] };
        segments.push(activeSegment);
        currentPointIndex = idx;
        return;
      }

      const p = points[idx];
      const lastP = points[currentPointIndex];
      const di = p.i - lastP.i;
      const dj = p.j - lastP.j;
      const isAdjacent = (Math.abs(di) <= 1 && Math.abs(dj) <= 1 && !(di === 0 && dj === 0));

      if (isAdjacent) {
        activeSegment.points.push(idx);
        currentPointIndex = idx;
      } else {
        // ë©€ë¦¬ ì°ìœ¼ë©´ ì í”„(ìƒˆ ì„¸ê·¸ë¨¼íŠ¸)
        activeSegment = { points: [idx] };
        segments.push(activeSegment);
        currentPointIndex = idx;
        setStatus("split");
      }
    }

    // ====== DRAW ======
    function drawGrid() {
      push();

      noStroke();
      fill(255, 250, 245);
      rect(gridMargin, gridMargin, width - 2 * gridMargin, height - 2 * gridMargin);

      stroke(255, 200, 195);
      strokeWeight(1);
      drawingContext.setLineDash([4, 4]);

      for (let i = 1; i < GRID_SIZE - 1; i++) {
        const y = gridMargin + i * spacing;
        line(gridMargin, y, width - gridMargin, y);
      }

      for (let j = 1; j < GRID_SIZE - 1; j++) {
        const x = gridMargin + j * spacing;
        line(x, gridMargin, x, height - gridMargin);
      }

      drawingContext.setLineDash([]);
      pop();
    }

    function drawPoints() {
      push();
      noStroke();
      fill(239, 65, 54, 150);
      const r = 2;

      for (const p of points) {
        if (startPoint && p.index === startPoint.index) continue;
        circle(p.x, p.y, r * 2);
      }
      pop();
    }

    function drawSegments() {
      if (!segments || segments.length === 0) return;

      const imac =
        (typeof IS_IMAC !== "undefined" && IS_IMAC) ||
        (window.screen.width >= 2400 && window.screen.height >= 1200);

      push();
      stroke(239, 65, 54);
      strokeWeight(imac ? 10 : 5);
      strokeCap(imac ? ROUND : SQUARE);
      noFill();

      for (const seg of segments) {
        if (!seg.points || seg.points.length < 2) continue;
        for (let k = 0; k < seg.points.length - 1; k++) {
          const a = points[seg.points[k]];
          const b = points[seg.points[k + 1]];
          line(a.x, a.y, b.x, b.y);
        }
      }

      pop();
    }



    function drawBoardLabels() {
      push();
      fill("#ffffff");
      noStroke();
      textAlign(CENTER, CENTER);

      const fs = Math.max(9, Math.min(14, canvasSize * 0.02));
      textSize(fs);

      const count = GRID_SIZE - 2; // 9
      const out = Math.max(14, gridMargin * 0.5);

      for (let k = 0; k < count; k++) {
        const n = String(k + 1).padStart(2, "0");
        const x = gridMargin + (k + 1) * spacing;
        const y = gridMargin + (k + 1) * spacing;

        text(`B-${n}`, x, gridMargin - out);
        text(`D-${n}`, x, height - gridMargin + out);
        text(`A-${n}`, gridMargin - out, y);
        text(`C-${n}`, width - gridMargin + out, y);
      }

      pop();
    }

    // ====== RESULT OVERLAY (O / X) ======
    function drawResultOverlay() {
      if (!resultMode || resultTimer <= 0) return;
      resultTimer--;

      const cx = width / 2;
      const cy = height / 2;
      const gridW = width - 2 * gridMargin;
      const baseR = gridW * 0.45;

      if (resultMode === "correct") {
        noFill();
        stroke(46, 204, 113);
        strokeWeight(14);
        circle(cx, cy, baseR);
      } else if (resultMode === "wrong") {
        stroke(220, 38, 38);
        strokeWeight(14);
        const r = baseR * 0.7;
        line(cx - r, cy - r, cx + r, cy + r);
        line(cx - r, cy + r, cx + r, cy - r);
      }
    }

    // ====== CONFETTI ======
    function spawnFancyConfetti() {
      const now = millis();
      confettiBurstUntil = now + 1400;
      for (let i = 0; i < 140; i++) confettiParticles.push(new ConfettiParticle());
    }

    function updateAndDrawConfetti() {
      push();
      blendMode(ADD);

      if (millis() < confettiBurstUntil) {
        for (let i = 0; i < 6; i++) confettiParticles.push(new ConfettiParticle());
      }

      for (let i = confettiParticles.length - 1; i >= 0; i--) {
        const p = confettiParticles[i];
        p.update();
        p.draw();
        if (p.dead) confettiParticles.splice(i, 1);
      }

      pop();
      blendMode(BLEND);
    }

    class ConfettiParticle {
      constructor() {
        this.x = random(width * 0.2, width * 0.8);
        this.y = random(-40, -10);
        this.vx = random(-1.8, 1.8);
        this.vy = random(2.2, 5.2);
        this.rot = random(TWO_PI);
        this.rotSpd = random(-0.18, 0.18);
        this.size = random(4, 14);
        this.life = 255;
        this.type = floor(random(3));
        this.base = color(239, 65, 54, 220);
        this.hi = color(255, 255, 255, 220);
        this.dead = false;
      }

      update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vx += sin(frameCount * 0.05 + this.rot) * 0.02;
        this.rot += this.rotSpd;
        this.life -= 4;
        if (this.life <= 0 || this.y > height + 40) this.dead = true;
      }

      draw() {
        push();
        translate(this.x, this.y);
        rotate(this.rot);

        noFill();
        stroke(red(this.hi), green(this.hi), blue(this.hi), this.life);
        strokeWeight(1);

        if (this.type === 0) {
          const w = this.size * random(0.7, 1.2);
          const h = this.size * random(0.4, 0.9);
          rectMode(CENTER);
          rect(0, 0, w + 1, h + 1, 2);

          noStroke();
          fill(red(this.base), green(this.base), blue(this.base), this.life);
          rect(0, 0, w, h, 2);

        } else if (this.type === 1) {
          ellipse(0, 0, this.size + 1, this.size + 1);

          noStroke();
          fill(255, 255, 255, this.life * 0.65);
          ellipse(-this.size * 0.15, -this.size * 0.15, this.size * 0.45);

          fill(red(this.base), green(this.base), blue(this.base), this.life);
          ellipse(0, 0, this.size);

        } else {
          stroke(255, 255, 255, this.life);
          strokeWeight(1.2);
          line(-this.size * 0.6, 0, this.size * 0.6, 0);
          line(0, -this.size * 0.6, 0, this.size * 0.6);

          noStroke();
          fill(255, 255, 255, this.life * 0.75);
          beginShape();
          vertex(0, -this.size * 0.6);
          vertex(this.size * 0.35, 0);
          vertex(0, this.size * 0.6);
          vertex(-this.size * 0.35, 0);
          endShape(CLOSE);
        }

        pop();
      }
    }

    // ====== UNDO ======
    function undoLastStep() {
      if (!segments || segments.length === 0) return;

      let s = segments.length - 1;
      while (s >= 0 && (!segments[s].points || segments[s].points.length === 0)) s--;
      if (s < 0) return;

      const seg = segments[s];

      if (seg.points.length > 1) {
        seg.points.pop();
        currentPointIndex = seg.points[seg.points.length - 1];
        activeSegment = seg;
      } else {
        segments.splice(s, 1);
        if (segments.length === 0) {
          activeSegment = null;
          currentPointIndex = null;
        } else {
          const lastSeg = segments[segments.length - 1];
          activeSegment = lastSeg;
          currentPointIndex = lastSeg.points[lastSeg.points.length - 1];
        }
      }

      segments = segments.filter(seg => seg.points && seg.points.length > 0);

      resultMode = null;
      resultTimer = 0;
      confettiParticles.length = 0;

      setStatus("undo");
    }

    // ====== RESULT CARD OVERLAY (USED) ======
    function showResultCard(src) {
      const overlay = document.getElementById("resultOverlay");
      const img = overlay.querySelector("img");
      img.src = src;
      overlay.classList.add("show");
    }

    function hideResultCard() {
      const overlay = document.getElementById("resultOverlay");
      overlay.classList.remove("show");
    }

    function bindOverlayClose() {
      const overlay = document.getElementById("resultOverlay");
      overlay.addEventListener("click", (e) => {
        if (e.target === overlay) hideResultCard();
      });
    }

    // ====== INK EFFECT ======
    function bindInkEffect() {
      window.addEventListener("mousedown", (e) => {
        const ink = document.createElement("div");
        ink.className = "ink";
        ink.style.left = e.clientX + "px";
        ink.style.top = e.clientY + "px";
        document.body.appendChild(ink);
        ink.addEventListener("animationend", () => ink.remove());
      });
    }
  </script>
</body>
</html>
